---
title: "[21.04.14] 백준문제풀이 - 기본수학 2 [1929번]"
date: 2021-04-14 16:00:28 -0400
toc: true
toc_sticky: true
categories: Algorithm_Problems
---

이번 포스팅은 백준 알고리즘 사이트의 기본수학 2단계의 1929번 문제입니다.

아래는 백준 알고리즘 사이트 URL입니다!

[백준 알고리즘 사이트 URL](https://www.acmicpc.net/)

# [1929번] 소수 구하기

## 문제

M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.
​

## 입력

첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.
​

## 출력

한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.

## 예시 입력
3 16 

## 예시 출력
3    
5     
7    
11    
13      

## 내 풀이 코드

	#include<stdio.h>
	int main(){
	    int M,N;
	    int a[1000001] = {0,1};
	    scanf("%d%d", &M, &N);
	    
	    for(int i=2; i<=N;i++){
	        for(int j=2;i*j<=N;j++){
	            a[i*j] = 1;
	        }
	    }
	    
	    for(int i=M;i<=N;i++){
	        if(!a[i])
	            printf("%d\n",i);
	    }
	}




		
		
## 내 풀이 해석	
처음 이 문제를 봤을 때, '아, 이전 문제들과 동일하게 이중첩 for문을 이용해서 풀면 되겠구나' 하고 단순하게 생각해서 코드를 제출했고, 

틀렸다. ㅎ

​

이전 문제들과 다르게 이 문제는 무지막지하게 큰 수가 입력되었을 때도 제한 시간 내에 출력이 가능하도록 코드를 작성해야 한다.

​

따라서 이 문제는 에레스토테네스의 체 방식까지 이용해야 풀 수 있다.

​

에레스토테네스의 체란 소수를 획기적으로 구할 수 있는 방법이다. 

​

예를 들자면,

(1) 2를 제외한 2의 배수를 모두 제외한다.

(2) 3을 제외한 3의 배수를 모두 제외한다.

.

.

.

이런 방식으로 계속 1씩 증가시키며 해당 수를 제외한 해당 수의 배수들을 지워나가면 결국 남는 수가 소수가 되는 점을 이용한 것!

​

이는 우리 코드에서 i번째 수의 배수들을 a[i] = 1로 바꿔준 뒤, 출력시 a[i]!=1인 경우의 i만 출력해주는 방식으로 이용할 수 있다.

​

그럼 본격적으로 main함수를 작성해 보자.

​

당연히 문제에서 주어진 변수 M,N을 먼저 선언한다.

또한 에레스토테네스의 체 방식을 이용하기 위해 배열 a[ ]도 선언하자. 

이때, 단순히 소수인지 아닌지를 판별하면 되므로 이 배열에는 소수이면 0, 소수가 아니면 1이 들어가게 한다.

그리고 배열 a[ ]을 선언과 동시에 0으로 초기화를 해주고, a[1]인 경우는 1로 초기화 해준다(1은 소수가 아니기 때문!)

	int M,N;
	int a[1000001] = {0,1};
​

이제 scanf 함수를 통해 M과 N을 입력받자.

	scanf("%d %d", &M, &N);
​

다음으로는 이중 중첩for문을 동일하게 이용하되, 해당 수를 제외한 해당 배수들의 경우, 배열값을 1로 바꾸어주는 코드를 작성하면 된다.

	for(int i=2; i<=N;i++){
	        for(int j=2;i*j<=N;j++){
	            a[i*j] = 1;
	        }
	    }
​

​

마지막으로는 배열값이 1이 아닌 값들을 출력하면 끝!

	for(int i=M;i<=N;i++){
	        if(!a[i])
	            printf("%d\n",i);
	    }
