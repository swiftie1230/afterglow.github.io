---
title: "[21.04.15] 백준문제풀이 - 기본수학 2 [4948번]"
date: 2021-04-15 08:35:28 -0400
categories: 백준문제풀이
---

이번 포스팅은 백준 알고리즘 사이트의 기본수학 2단계의 4948번 문제입니다.

아래는 백준 알고리즘 사이트 URL입니다!

[백준 알고리즘 사이트 URL](https://www.acmicpc.net/)

# [4948번] 베르트랑 공준

## 문제

베르트랑 공준은 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다.

이 명제는 조제프 베르트랑이 1845년에 추측했고, 파프누티 체비쇼프가 1850년에 증명했다.

예를 들어, 10보다 크고, 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19) 또, 14보다 크고, 28보다 작거나 같은 소수는 3개가 있다. (17,19, 23)

자연수 n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하시오. 
​

## 입력

입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 케이스는 n을 포함하는 한 줄로 이루어져 있다.

입력의 마지막에는 0이 주어진다.
​

## 출력

각 테스트 케이스에 대해서, n보다 크고, 2n보다 작거나 같은 소수의 개수를 출력한다.

## 예시 입력
1
10
13
100
1000
10000
100000
0


## 예시 출력
1
4
3
21
135
1033
8392 

## 내 풀이 코드

	#include<stdio.h>
	int main(){
	
		while(1){
	        int a[1000001] = {0,1};
	        int count = 0;
	        int N;
	        scanf("%d", &N);
	        
	        if(N==0){
	            break;
	        }
	        
	        for(int i=2; i<+2*N;i++){
	            for(int j=2;i*j<=2*N;j++){
	                a[i*j] = 1;
	            }
	        }
	        
	        for(int i=N+1;i<=2*N;i++){
	            if(!a[i])
	                count++;
	            else
	                continue;
	        }
	        printf("%d\n", count);
	    }
	    
	    
	    return 0;
	}




		
		
## 내 풀이 해석	
이 문제는 전단계 문제의 해결방법과 동일하게 에라스토테네스의 체 방식을 이용하여 접근해 보았다.

전단계 문제에 에라스토테네스의 체 방식과 이중 중첩 for문으로 코드로 구현하는 방법을 간단하게 설명해 놓았으니 혹시 잘 모른다면 참고해 보길 바란다!

​
[전단계 문제 - 에라스토테네스의 체 방식](https://swiftie1230.github.io/%EB%B0%B1%EC%A4%80%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/%EB%B0%B1%EC%A4%80%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-1929%EB%B2%88/)   

우선, 입력은 N 한개이고, 입력받은 N부터 2N까지의 소수의 개수를 출력하는 코드를 작성하면 된다.

이 과정을 0이 입력될 때까지 반복해야 하므로 무한 루프 while문을 이용하고, 0이 입력되었을 때 break하도록 코드를 짜봤다.

**이번 코드 설명은 각 코드의 주석으로 작성했다!*

	while(1) // 무한 루프 while
	{ 
	        int a[1000001] = {0,1}; // 에라스토테네스의 체 방식으로 접근하기 위해 배열을 선언하고 0,1(1은 소수가 아니므로)로 초기화 해주었다. 에라스토테네스 체 방식의 자세한 설명은 바로 전단계인 1929번 해설을 참고하기 바란다.
	        int count = 0; //소수의 개수를 저장하는 변수 count 선언하고 0으로 초기화
	        int N; // 입력받을 수를 저장할 변수 N 선언
	        scanf("%d", &N); //입력받는다.
	        
	        if(N==0){  // 0을 입력받을 시 break로 무한 루프를 빠져나온다.
	            break; 
	        }
	        
	        for(int i=2; i<=2*N;i++){  //에라스토테네스의 체 방식을 구현하는 이중 중첩 for문. 
	            for(int j=2;i*j<=2*N;j++){
	                a[i*j] = 1;
	            }
	        }
	        
	        for(int i=N+1;i<=2*N;i++){ // 이제 문제에서 주어진 N보다 크고 2N보다 작거나 같은 범위의 수가 소수일 경우(a[i]=0인 경우), count를 1씩 증가시키고 아니라면 continue!
	            if(!a[i])
	                count++;
	            else
	                continue;
	        }
	        printf("%d\n", count); // 마지막으로 "한 줄에 한 수씩", count를 출력해준다.
	    }
