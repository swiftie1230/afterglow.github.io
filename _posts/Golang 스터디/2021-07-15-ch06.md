---
title: "[21.07.15] Golang_스터디 CH_06"
date: 2021-07-15 16:00:28 -0400
toc: true
toc_sticky: true
categories: Golang_Study
---


# 연산자

##  1. 산술 연산자

숫자 연산을 하는 연산자를 의미한다. 사칙 연산, 비트 연산, 시프트 연산이 이에 속한다.

Go 언어에서 모든 연산자의 각 항의 타입은 항상 같아야 한다 (시프트 연산은 예외). 

### [1] 비트 연산자
비트 단위로 연산을 수행한다. 그래서 비트 연산을 위해서는 먼저 정숫값을 2진수로 표현한 뒤 계산해야 한다.

> `&` (AND 연산자)  
>`|` (OR 연산자)  
> `^` (XOR 연산자)  
> `&^` (비트 클리어 연산자)  

### [2] 시프트 연산자
비트를 왼쪽, 또는 오른쪽으로 밀거나 당기는 연산자이다.

>  `>>` : 오른쪽 피연산자값 만큼 비트값을 오른쪽으로 민다.    
>  `<<`: 오른쪽 피연산자값 만큼 전체 비트를 왼쪽으로 밀어낸다.


##  2. 비교 연산자
양변을 비교해서 조건에 만족하면 불리언값 true를, 만족하지 못할 경우 false를 반환하는 연산자이다.   
`==`, `!=`, `<`, `>`, `<=`, `>=` 연산자를 제공한다.

* 단, **부호가 있는 정수**를 사용할 때 발생하는 **오버플로**와 **언더플로** 문제, **실수끼리의 비교**에 주의하자! 


##  3. 실수 오차
컴퓨터에서는 실수값을 표현할 때 **지수부**와 **소수부**로 나누어서 표현한다. 컴퓨터는 지수부와 소수부가 10진수 기준이 아니라 2진수 기준으로 되어 있다.   
그래서 10진수 실수를 정확히 표현하기 어려운 문제가 있다.   
즉, 오차가 발생할 수 있다는 소리! 이런 허용 오차를 줄이기 위해서는 어떻게 해야 할까.

허용 오차를 줄이는 방법 세가지는 다음과 같다.

> 1. **매우 작은 값을 선정해서 오차를 무시하는 방법** :     
>> 매우 작은 상숫값 선언해서 무시한다.    
>> 

> 2. **math 패키지의 NextAfter() 함수를 사용하는 방법** :     
> > 1비트 차이만큼 비교한다.
> > 즉, 가장 마지막 비트가 1비트만큼 차이난다면 인정!
> 
> 3. **math/big의 Float를 사용하는 방법** :    
> > math/big 패키지의 Float 객체를 이용!

##  4. 논리 연산자

불리언 피연산자를 대상으로 연산해 결과로 true나 false를 반환한다.  
`&&`와 `||`는 피연산자가 둘이고, `!`는 하나이다.  
이 부분은 간단하고, 다른 언어와 동일하므로 생략한다.

##  5. 대입 연산자

복수 대입 연산자만 기억해두자! 파이썬과 동일하게 두 변수의 값을 서로 바꿀 수 있다는 것!

나머지는 역시 동일하므로 생략한다.

## 6. 연산자 우선순위

연산자에도 우선순위가 존재한다.   
다만, 연산자 우선순위가 있다고 해도 소괄호()로 묶어서 보기 편하게 만들어주는 게 좋다.   

ex) `(((3*4) ^ (7<<2)) + (3*5)) == 7`이라고 쓰는 게 더 가독성 좋은 코드이다.

# 관련 추가 과제

## 1. 다음 예제의 결과를 쓰세요.

	package main
	
	import "fmt"
	
	func main() {
		var a int8 = 30
		
		a <<= 2
		a += 8
		fmt.Println(a)
	}

`a <<= 2`는 `a = a << 2`를 의미한다.  
따라서 `a = 30*4 = 120`이다.
`120 + 8 = 128 `이지만, int8의 범위는 `127`까지이므로, 오버플로우 되어 `-128`이 답이다.

### A) -128

## 2. 다음 예제의 결과를 쓰세요.

	package main
	
	import "fmt"
	
	func main() {
		var a uint8
		
		a |= 2
		a |= 4
		a |= 8
		
		var b uint8
		b = 4
		
		a &^= b
		fmt.Println(a)
	}

`a |= 2`는 a와 2를 or 연산한 값을 a에 대입하라는 의미이므로 2, 
동일하게 수행하면 다음은 6, 그 다음은 14가 된다.

b는 4이고,  `&^`는 a에서 b값에서 1인 비트를 클리어하라는 의미이므로, 3번째 비트가 클리어 된다. 따라서 답은 `0000 1010`인 10이다.

### A) 10

## 3. 다음 예제의 결과를 쓰세요.

	package main
	
	import "fmt"
	
	func main() {
		var x int8 = 1
		x <<= 7
		x >>= 7
		fmt.Printf("%d\n", x)
	}

`0000 0001` -> 왼쪽으로 7번 쉬프트 -> `1000 0000` -> 오른쪽으로 7번 쉬프트 -> 맨 왼쪽에 같은 부호 비트가 채워지므로 `1111 1111` 즉, `-1`
### A) -1
