---
title: "[21.08.30] Golang_스터디 CH_20"
date: 2021-08-30 15:00:28 -0400
toc: true
toc_sticky: true
categories: Golang_Study
---


# 💭 인터페이스 

**인터페이스<sup>interface</sup>**를 이용하면 메서드 구현을 포함한 구체화된 객체<sup>concrete object</sup>가 아닌 **<u>추상화된 객체</u>로 상호작용**할 수 있다.

##  1. 인터페이스

### 📌 <u>인터페이스 선언</u>

인터페이스 선언은 `type`을 쓴 뒤 `인터페이스명`을 쓰고 `interface` 키워드를 쓴 후, 중괄호 `{ }` 블록 안에 인터페이스에 포함된 메서드 집합을 써주면 끝!        

   ```go
type DuckInterface interface {
	Fly()
	Walk(distance int) int
}
   ```    

<div class="notice--primary" markdown="1">
🌝 <strong><u>여기서 잠깐!</u></strong>       

중괄호 블록 안, 인터페이스에 포함된 메서드 집합을 써 줄 때 <strong>세 가지 유의 사항</strong>이 있다.      

1. 메서드는 반드시 메서드 명이 있어야 한다.   

2. 매개변수와 반환이 다르더라도 이름이 같은 메서드는 있을 수 없다.    

3. 인터페이스에서는 메서드 구현을 포함하지 않는다.                       
      
</div>

**인터페이스의 메서드 집합을 가지는 타입은 해당 인터페이스로 사용될 수 있다.**    


##  2. 인터페이스 왜 쓰나?

인터페이스는 객체 지향 프로그래밍에서 아주 중요한 역할을 한다.       
인터페이스를 이용하면 구체화된 객체가 아닌 **<u>인터페이스만 가지고 메서드를 호출</u>**할 수 있기 때문에 **큰 코드 수정 없이 <u>필요에 따라 구체화된 객체를 바꿔서 사용할 수 있게 됨.</u>**         
즉, **<u>코드를 유연하게 사용할 수 있는 편리함</u>을 인터페이스가 제공한다**고 할 수 있다.       

### 📌 <u>추상화 계층</u>

내부 동작을 감춰서 서비스를 제공하는 쪽과 사용하는 쪽 모두에게 자유를 주는 방식을 추상화<sup>abstraction</sup>이라고 한다.    
**구체화된 타입으로 상호작용하는 게 아니라 <u>관계로 상호작용</u>**하며, **<u>그 관계를 정의한 추상화 계층</u>이 바로 <u>인터페이스</u>인 것**이다.  
 

## 3. 덕 타이핑

Go 언어에서는 **어떤 타입이 인터페이스를 포함하고 있는지 여부를 결정**할 때 **덕 타이핑<sup>duck typing</sup> 방식**을 사용한다.      
**덕 타이핑 방식**이란 **타입 선언 시 인터페이스 구현 여부를 명시적으로 나타낼 필요 없이 <sup>인터페이스에 정의한 메서드 포함 여부만으로 결정</sup>하는 방식**이다.         

덕 타이핑의 장점은 **서비스 사용자 중심의 코딩을 할 수 있다는 점**이다.     
덕 타이핑에서는 **인터페이스 구현 여부를 타입 선언에서 하는 게 아니라 인터페이스가 사용될 때 해당 타입이 인터페이스에 정의된 메서드를 포함했는지 여부로 결정**한다.      
따라서 서비스 제공자가 **인터페이스를 정의할 필요 없이 구체화된 객체만 제공**하고, 서비스 이용자가 필요에 따라 그때 그때 인터페이스를 정의해서 사용할 수 있다.    


## 4. 인터페이스 기능 더 알기

인터페이스의 기본 기능 외 3가지 다른 기능을 알아보자.    

### 📌 [1] <u>인터페이스를 포함하는 인터페이스</u>

구조체에서 다른 구조체를 포함된 필드로 가질 수 있듯이 인터페이스도 다른 인터페이스를 포함할 수 있다.     

이 때, 해당 메서드를 가지고 있는지의 여부에 따라 사용할 수 있는 인터페이스도 달라진다.    

### 📌 [2] <u>빈 인터페이스 interface{ }를 인수로 받기</u>

interface{ }는 메서드를 가지고 있지 않은 빈 인터페이스이다. 가지고 있어야 할 메서드가 하나도 없기 때문에 모든 타입이 빈 인터페이스로 쓰일 수 있다.   
빈 인터페이스는 어떤 값이든 받을 수 있는 함수, 메서드, 변숫값을 만들 때 사용한다.        

### 📌 [3] <u>인터페이스 기본값 nil</u>

인터페이스 변수의 기본값은 유효하지 않은 메모리 주소를 나타내는 nil이다.    

인터페이스의 초깃값을 지정해 주지 않으면 기본값인 nil이 할당되어 런 타임 에러가 발생할 수 있다.         
따라서 인터페이스를 사용할 때는 항상 인터페이스값이 nil이 아닌지 확인해야 한다.     

<div class="notice--primary" markdown="1">
🌝 <strong><u>여기서 잠깐!</u> : <u>컴파일 에러와 런 타임 에러</u></strong>       

에러는 크게 컴파일 타임 에러와 런 타임 에러로 나뉘는데, 컴파일 타임 에러는 주로 문법 오류에서 발생하는 반면 런 타임 에러는 문법에는 문제가 없으나 값이 비정상적인 경우에 발생한다.                            
      
</div>


## 5. 인터페이스 변환하기

인터페이스 변수를 타입 변환을 통해서 구체화된 다른 타입이나 다른 인터페이스로 변환할 수 있다.        

### 📌 [1] <u>구체화된 다른 타입으로 타입 변환하기</u>

인터페이스 변수 뒤에 점.을 찍고 소괄호 `( )` 안에 변경하려는 타입을 써 주면 된다.       

   ```go
var a Interface
t := a.(ConcreteType)
   ```
이 때 인터페이스 변수를 구체화된 타입으로 타입 변환하려면 **해당 타입이 인터페이스 메서드 집합을 포함**하고 있어야 하며, 그렇지 않을 경우 컴파일 에러가 발생한다.    

또, 변환하려는 타입이 인터페이스를 이미 포함하고 있다고 하더라도 실제 인터페이스 변수가 가리키는 인스턴스가 변환하려는 타입이 아닌 경우에는 컴파일 타임 에러가 아니라 실행 중에 발생하는 에러인 런 타임 에러가 발생한다.      
### 📌 [2] <u>다른 인터페이스롤 타입 변환하기</u>

인터페이스 변환을 통해 구체화된 타입뿐 아니라 다른 인터페이스로 타입 변환할 수 있다.   
이 때는 구체화된 타입으로 변환할 때와는 달리 변경되는 인터페이스가 변경 전 인터페이스를 포함하지 않아도 된다.    
그러나 **<u>인터페이스가 가리키고 있는 실제 인스턴스가 변환하고자 하는 다른 인터페이스를 포함</u>해야 한다.**            

### 📌 [3] <u>타입 변환 성공 여부 반환</u>

**<u>타입 변환 반환값을 두 개 변수</u>로 받으면 <u>타입 변환 가능 여부를 두 번째 반환값(불리언 타입)으로 알려주고</u>, 타입 변환이 설령 불가능하더라도 두 번째 반환값이 false로 반환될 뿐 <u>런 타임 에러는 발생하지 않는다</u>.**        

       
# 🌟 오늘의 핵심      

<div class="notice--primary" markdown="1">

1. 인터페이스는 메서드 집합체이다.          
  
2. 인터페이스에서 정의한 메서드 집합을 가진 모든 타입은 인터페이스로 쓰일 수 있다.            

3. 덕 타이핑이란 인터페이스 구현 여부를 명시적으로 선언하는 게 아닌 인터페이스에서 정의한 메서드 포함 여부로 판단한다.              

4. 인터페이스를 사용해 추상화 계층을 만들고 관계를 통한 상호작용을 정의한다.    

5. 모든 타입이 빈 인터페이스 변숫값으로 쓰일 수 있다.    

6. 인터페이스 변환을 사용하면 인터페이스 변수를 구체화된 타입이나 다른 인터페이스로 변경할 수 있다.

</div>

_


# 👩🏻‍💻 관련 추가 과제

## 1번
Q) 다음 예제에서 컴파일 에러가 발생하는 이유를 쓰세요.     

   ```go
package main

type ReadWriter interface {
	Read()
	Write()
}

type File struct {

}

func (f *File) Read() {

}

func ReadWrite(rw ReadWriter) {
	rw.Read()
	rw.Write()
}

func main() {
	f := &File{}
	ReadWrite(f)
}
   ```   

A) 

File 구조체가 Read() 메서드만 가지고 있어 ReadWriter 인터페이스로 사용할 수 없다.

## 2번 

Q) 다음 패키지 OurDB 구조체의 모든 공개된 메서드를 이용하는 인터페이스를 만들어보세요.            

   ```go
package AwesomeDB

type OurDB struct {
	Name string
}

func (db *OurDB) GetData() string {
	...
}

func (db *OurDB) WriteData(data string) {
	...
}

func (db *OurDB) Close() error {
	...
}
   ```

A) 

   ```go
type DB interface {
	GetData() string
	WriteData(data string)
	Close() error
}
   ```

## 3번 

Q) 어떤 경우에도 런 타임 에러가 발생하지 않도록 CheckAndRun() 함수를 수정하세요.                  

   ```go
type Stringer interface {
	String()
}

type Reader interface {
	Read()
}

func CheckAndRun(stringer Stringer) {
	r := stringer.(Reader)
	r.Read()	
}
   ```

A) 

   ```go
type Stringer interface {
	String()
}

type Reader interface {
	Read()
}

func CheckAndRun(stringer Stringer) {
	if r, ok := stringer.(Reader); ok {
		r.Read()
	}	
}
   ```
