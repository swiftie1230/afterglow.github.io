---
title: "[21.08.09] Golang_스터디 CH_15"
date: 2021-08-09 15:00:28 -0400
toc: true
toc_sticky: true
categories: Golang_Study
---


# 💭 문자열 

##  1. 문자열이란?

**문자열**은 **문자 집합**으로, **큰따옴표**나 **백쿼트**<sup>back quote</sup>로 묶어서 표시한다.    

<div class="notice--primary" markdown="1">
🌝 <strong><u>여기서 잠깐!</u> : <u>백쿼트는 뭘까?</u></strong>      

<strong>그레이브</strong>라고도 불리며, 키보드에서 물결 표시 아래에 있는 기호 <code>`</code>를 말한다.      

다만 큰따옴표와 백쿼트는 그 쓰임이 다른데, <u>백쿼트로 문자열을 묶으면 문자열 안의 특수 문자가 일반 문자처럼 처리</u>됨!     
또한 <u>백쿼트로 묶을 경우 여러 줄에 걸쳐서 문자열을 쓸 수 있지만 큰따옴표로는 한 줄만 묶을 수 있다.</u>     

이처럼 백쿼트를 이용하면 <strong>여러 줄에 걸친 문자열</strong>과 <strong>특수문자</strong>를 간편히 출력할 수 있다.

</div>  

<div class="notice--primary" markdown="1">
💡 <strong><u>추가 지식!</u> : <u>큰따옴표 내에서 특수 문자를 문자 그대로 출력하고 싶다면?</u></strong>      

그대로 출력하고 싶은 특수문자에 역슬래시를 두 번 적어주면 된다!    

예를 들어,      
   ```go
Hello\tWorld\n
   ```     
이렇게 출력하고 싶다면    

   ```go
fmt.Println("Hello\\tWorld\\n")
   ``` 

위와 같이 적어주면 됨!          
</div> 

### 📌 [1] UTF-8 문자코드

Go는 UTF-8 문자코드를 표준 문자코드로 사용한다.    

UTF-16이 한 문자에 2바이트를 고정 사용하는 것과 달리 UTF-8은 자주 사용되는 영문자, 숫자, 일부 특수 문자를 1바이트로 표현하고 그 외 다른 문자들은 2-3바이트로 표현한다.      
그렇기에 UTF-16에 비해 크기를 절약할 수 있고, ANSI 코드와 1:1 대응이 되어 ANSI로 바로 변환된다는 장점이 있음!      

Go는 UTF-8을 표준 문자코드로 사용하기 때문에 별다른 변환없이 한글이나 한자 등을 사용할 수 있다.      
       

### 📌 [2] rune 타입으로 한 문자 담기
       
문자 하나를 표현할 때, 한 글자가 1-3바이트 크기인 UTF-8 문자값을 가지려면 3바이트가 필요한데, Go 언어 기본 타입에서 3바이트 정수 타입은 제공되지 않음....    
이때 우리는 4바이트 정수 타입인 int32타입의 별칭 타입인 **rune타입**(rune 타입과 int32는 이름만 다를 뿐 같은 타입이다.)을 사용하여 나타낼 수 있다!                    

   ```go
package main

import "fmt"

func main() {
	var char rune = '한'

	fmt.Printf("%T\n", char)
	fmt.Println(char)
	fmt.Printf("%c\n", char)
}
   ```
위의 예시 출력 결과는 다음과 같다.       

   ```go
int32
54620
한
   ```

`%T`를 이용하여 `char` 변수의 타입을 출력한 결과, `rune` 타입은 `int32` 타입과 같기 때문에 `int32`가 출력된 것을 확인할 수 있다!         
또한 `char`값을 출력하면 타입이 `int32`라서 숫자로 출력되고, `%c` 포맷을 이용하여 출력해야 해당 문자 형태를 출력할 수 있음을 알 수 있다.           

### 📌 [3] len()으로 문자열 크기 알아내기

`len()` 내장 함수를 이용해서 **문자열 크기**를 알 수 있는데, 이 때 크기는 **문자 수가 아니라 말 그대로 문자열이 차지하는 메모리 크기**이다!      

### 📌 [4] []rune 타입 변환으로 글자 수 알아내기

`string` 타입과 `rune 슬라이스` 타입은 상호 타입 변환이 가능함!       
즉, 문자열은 각 문자의 코드값의 배열인 `rune` 배열로 나타낼 수 있으며, 이렇게 타입 변환을 할 경우 `rune` 배열의 각 요소에는 문자열의 각 글자가 대입된다.    

즉, 문자열을 `rune` 배열로 변환 후, 이 `rune` 배열의 `len()`로 배열의 요소 개수, 즉, 문자열의 글자 수를 알아낼 수 있는 것이다!

<div class="notice--primary" markdown="1">
💡 <strong><u>추가 지식!</u></strong>        

사실 string 타입은 연속된 바이트 메모리라면  []rune 타입은 글자들의 배열로 이루어져 있는, 서로 완전히 다른 타입이다.     
그러나 Go언어는 편의를 위해서 둘의 상호 타입 변환을 지원하고 있음.                      
</div> 


##  2. 문자열 순회

문자열에 들어있는 글자들을 순회하는 방법은 크게 3가지가 있다.       

### 📌 [1] 인덱스를 사용해 바이트 단위 순회하기

**인덱스를 사용**해 직접 접근하는 방법이다.                           

다만, `str[i]` 처럼 인덱스로 접근하면 요소의 타입은 `uint8` 즉, `byte`이다.      
그렇기에 1바이트 크기인 영문자는 잘 표시되는데 3바이트 크기인 **한글은 깨져 표시**된다.    

### 📌 [2] []rune으로 타입 변환 후 한 글자씩 순회하기

한글이 섞인 문자열을 `[]rune` 타입으로 변환한 다음에 순회하는 방법이다.    

이 방법은 한 글자씩 순회하며, 모든 문자를 깨짐 없이 출력할 수 있지만 , `[]rune`으로 변환되는 과정에서 별도의 배열을 할당하므로 **불필요한 메모리를 사용**하게 된다.        

### 📌 [3] range 키워드를 이용해 한 글자씩 순회하기

`range` 키워드를 이용해서 순회하는 방법이다.      

이처럼 `range`를 이용하면 추가 메모리 할당 없이 문자열을 한 글자씩 순회할 수 있어서 불필요한 메모리 낭비를 없앨 수 있다.      


##  3. 문자열 연산

### 📌 [1] 문자열 합치기

문자열은 `+`과 `+=` 연산을 사용해서 문자열을 이을 수 있다.           

<div class="notice--primary" markdown="1">
🌝 <strong><u>여기서 잠깐!</u></strong>      

문자열 연산으로는 <code>+</code> 연산자만 제공되고 <code>-</code>나 <code>*</code> 연산자는 제공되지 않는다.         
      
</div> 
    

### 📌 [2] 문자열 비교하기

연산자 `==`, `!=`를 사용해서 문자열이 같은지, 같지 않은지 비교할 수 있다.     
두 문자열이 완전히 같을 때 `==` 연산 결과가 `true`가 되고 `!=` 연산은 `false`가 되는 식!                       

<div class="notice--primary" markdown="1">
🌝 <strong><u>여기서 잠깐!</u></strong>      

연산자 <code>==</code>는 익숙한데, <code>!=</code> 가 익숙하지 않은 사람도 있을 것이다!      
이는 <code>==</code> 연산과 반대 결과를 알려준다고 생각하면 편함 :)       
      
</div>         
   

### 📌 [3] 문자열 대소 비교하기 

`>`, `<`, `>=`, `<=` 연산자를 이용해서 문자열 간 대소를 비교할 수 있다.    
문자열 대소 비교는 첫 글자부터 하나씩 값을 비교해서 **그 글자에 해당하는 유니코드 값의 대소를 반환**하며, 값이 같을 경우 다음 글자를 비교한다.        

<div class="notice--primary" markdown="1">
🌝 <strong><u>여기서 잠깐!</u></strong>      

문자열 대소 비교시 문자열 길이와 상관없이 앞글자부터 (같은 위치에 있는 글자끼리) 비교한다.           
      
</div>

##  4. 문자열 구조

사실 문자열을 사용하는 데 있어서 string 자료구조까지 알 필요는 없다.  그러나 내부 구조를 이해하면 Go 프로그래밍을 이해하는 데 큰 도움이 됨!      

### 📌 [1] string 구조 알아보기

string의 구조는 다음과 같다.                 

   ```go
type StringHeader struct {
	Data uintptr
	Len   int
}
   ```
`string`은 필드가 2개인 구조체로, 첫 번째 필드 `Data`는 `uintptr` 타입으로 문자열의 데이터가 있는 메모리 주소를 나타내는 일종의 포인터이고, 두 번째 필드 `Len`은 `int`타입으로 문자열의 길이를 나타낸다!        

### 📌 [2] string끼리 대입하기

`str1` 변수를 `str2`에 대입하면 `str1` 값이 `str2`에 복사된다.       

구조체 변수가 복사될 때 구조체 크기만큼 메모리가 복사, 즉, 각 필드인 `Data` 포인터 값과 `Len`값이 복사되며, 당연히 문자열 자체는 복사되지 않는다! 

##  5. 문자열은 불변이다

문자열은 **불변**<sup>immutable</sup>으로, 이는 string 타입이 가리키는 **문자열의 일부만 변경할 수 없다**는 말이다.          

`str`값을 다른 문자열로 바꾸기는 가능하다. 그러면 `str`은 바뀌는 문자열이 있는 메모리 주소로 `Data` 포인터값을 변경하고 `Len`값도 문자열 길이에 맞게 변경한다.    

그러나 **문자열의 일부를 바꿀 수는 없음**!     

**문자열 합산이 일어날 때도 문자열 불변 원칙은 준수**되는데, Go언어는 기존 문자열 메모리 공간을 건드리지 않고 새로운 메모리 공간을 만들어서 두 문자열을 합치기 때문에 `string` 합 연산 이후 주솟값이 변경된다!

<div class="notice--primary" markdown="1">
🌝 <strong><u>여기서 잠깐!</u></strong>      

그럼 왜 Go언어는 빈번한 합 연산 시 메모리가 낭비되는데도 문자열 불변 원칙을 지키려 하는 걸까.     

가장 큰 이유는 문자열이 언제라도 변화할 수 있을 때 발생하는 예기치 못한 버그를 방지하기 위해서이다.               
만약 string 변숫값이 코드 전반에 걸쳐서 여러 곳으로 복사됐다면 언제 어디에서 문자열이 변경되는지 알 수 없어서 많은 버그를 양산할 수 있음.        
      
</div>     

<div class="notice--primary" markdown="1">
💡 <strong><u>추가 지식!</u> : <u>합 연산이 빈번할 때는 strings.Builder!</u></strong>      

<code>string</code> 합 연산이 빈번하면 메모리가 낭비되기 십상이다.   
이럴 때는 <code>strings.Builder</code>를 사용하는 것이 좋다!       

<code>strings.Builder</code>는 내부에 슬라이스를 가지고 있기 때문에 <code>WriteRune()</code> 메서드를 통해 문자를 더할 때 매번 메모리를 새로 생성하지 않고 기존 메모리 공간에 빈자리가 있으면 그냥 더한다.      
그래서 메모리 공간 낭비를 줄일 수 있음!              
</div>  

_


# 👩🏻‍💻 관련 추가 과제

## 1. 다음 예제의 결과를 쓰세요.

   ```go
package main

import "fmt"

func main() {
	str1 := "학교종이 "
	str2 := "땡땡땡"
	str1 += str2

	fmt.Println(str1)
}
   ```

str1 = str1 + str2 연산을 수행 !

### A) 

   ```go
학교종이 땡땡땡
   ```

## 2. 다음은 소문자를 대문자로 바꾸는 함수입니다. 공란을 채우세요.

   ```go
package main

import (
	"fmt"
	"strings"
)

func ToUpper(str string) string {
	var builder strings.Builder
	for _, v := [      ] str {
		if v >= 'a' && v <= 'z' {
			builder.WriteRune('A' + (v - 'a'))
		} else {
			builder.WriteRune(v)
		}
	}
	return builder.String()
}

func main() {
	str1 := "Hello World!"

	fmt.Println(ToUpper(str1))
}
   ```


`range` 키워드 사용해서 순환하는 예제이다!       

### A) range


## 3. 64비트 컴퓨터애서 다음 구조체의 크기를 적어보세요.

   ```go
type User struct {
	FirstName string
	LastName  string
	Age       int
}
   ```

string 구조체는 필드 두개를 가지고 있기에 16바이트 크기를 가짐!       

### A) 40바이트
