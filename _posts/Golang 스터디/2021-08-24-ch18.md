---
title: "[21.08.24] Golang_스터디 CH_18"
date: 2021-08-24 15:00:28 -0400
toc: true
toc_sticky: true
categories: Golang_Study
---


# 💭 슬라이스 

##  1. 슬라이스

**<u>슬라이스</u>**를 사용하면 **처음 배열을 만들 때 정한 길이에서 더 이상 늘어나지 않는 배열의 불편함을 해결**할 수 있다.    


### 📌 [1] <u>슬라이스 선언</u>

슬라이스는 배열과 비슷하지만 **[] 안에 배열의 개수를 적지 않고 선언**한다.            

슬라이스를 **초기화하지 않으면 길이가 0인 슬라이스**가 만들어지며, **슬라이스 길이를 초과해서 접근하면 런 타임 에러가 발생**한다.     

초기화 방법으로는 **배열처럼 { }를 사용해 요솟값을 지정하는 방법**과, **`make` 내장 함수를 이용하는 방법**이 존재한다. 

#### 🔑 (1) <u>{ }를 이용해 초기화하기</u>

   ```go
var slice1 = []int{1, 2, 3}
var slice2 = []int{1, 5:2, 10:3}
   ```
위와 같이 초기화하면` slice1`은 1, 2, 3을 값으로 갖는 슬라이스 `[1, 2, 3]`가 되며, `slice2`의 첫번째 요소는 1이 되고, 인덱스 10인 요소는 3이 되어서 총 11개의 요소를 갖는 슬라이스 `[1 0 0 0 0 2 0 0 0 0 3]`가 된다. 

#### 🔑 (2) <u>`make()`를 이용해 초기화하기</u>

**`make()` 함수**의 **첫번째 인수로는 만들고자 하는 타입**을, **두번째 인수로는 길이**를 적어주면 된다.     

   ```go
var slice = make([]int, 3)
   ```
   
위와 같이 하면 `slice` 변수는 길이 3개짜리 int 슬라이스값을 가지며, 각 슬라이스 요솟값은 Int 타입의 기본값인 `0`이 된다.

### 📌 [2] <u>슬라이스 요소 접근</u>

배열과 동일함.    
**대괄호<sup>[ ]</sup> 사이**에 **인덱스**를 써서 각 요소에 접근하면 된다.     

### 📌 [3] <u>슬라이스 순회</u>

역시 배열과 동일하다. 동적으로 길이가 늘어나는 점만 제외하면 배열과 사용법이 같다고 보면 된다.     

### 📌 [4] <u>슬라이스 요소 추가: `append()`</u>    

이제 슬라이스만의 기능인 요소를 추가하는 방법을 보자. 기존 배열은 한 번 길이가 정해지면 늘릴 수 없지만 슬라이스는 요소를 추가해 길이를 늘릴 수 있다.    

요소 추가에는 **`append()` 내장함수**를 사용하는데, `append()`는 **첫 번째 인수로 추가하고자 하는 슬라이스**를 적고, **그 뒤에 요소**를 적어주면 **슬라이스 맨 뒤에 요소를 추가해 만든 새로운 슬라이스를 결과로 반환**한다.

이 **`append()`**를 사용해서 **값을 하나 이상 추가**할 수도 있는데, 

   ```go
slice = append(slice, 3, 4, 5, 6, 7)
   ``` 
위와 같이 **첫 번째 인수로 추가하고자 하는 슬라이스**를 적어주고, **두 번째 인수 이후로 추가하고 싶은 값들**을 적어주면 **이후 값들이 슬라이스에 추가된 뒤 만들어진 새로운 슬라이스를 반환**한다.  

<div class="notice--primary" markdown="1">
🌝 <strong><u>여기서 잠깐!</u></strong>    

<code>append()</code>는 첫 번째 인수로 들어온 슬라이스 값을 변경하는 게 아니라, <strong>요소가 추가된 새로운 슬라이스를 반환</strong>한다. 그렇기 때문에 <strong><u>기존 슬라이스에 요소를 추가</u>하고 싶을 땐 <u><code>append()</code> 결과를 기존 슬라이스에 대입 후 변경</u></strong>해야 한다.                 
      
</div>

##  2. 슬라이스 동작 원리

슬라이스는 배열과 사용법이 비슷하면서 동적으로 요소를 추가할 수 있는 동적 배열로 동작한다.     
그러나 **<u>*슬라이스와 배열은 중요한 차이점이 있음!*</u>**      
이 차이점을 잘 이해해야지만 슬라이스를 잘 사용할 수 있으며, **제대로 이해하지 않으면 예기치 못한 버그가 발생**할 수 있으니, 꼭 알아두자.       

우선, 슬라이스는 내장 타입으로 내부 구현이 감춰져 있지만, `reflect` 패키지의 `SliceHeader` 구조체를 사용해 내부 구현을 살펴볼 수 있다고 한다.      
슬라이스의 내부 정의는 다음과 같다.    

   ```go
type SliceHeader struct {
	Data uintptr	// 실제 배열을 가리키는 포인터
	Len int			// 요소 개수
	Cap int			// 실제 배열의 길이
}
   ```

슬라이스 구현은 **배열을 가리키는 <u>포인터</u>**와 **요소 개수를 나타내는 <u>len()</u>**, **전체 배열의 길이를 나타내는 <u>cap</u> 필드**로 구성된 구조체이다.     

### 📌 [1] <u>make() 함수를 이용한 선언</u>

`make()` 함수를 이용하여 슬라이스를 만들 때, 인수를 **2개 혹은 3개를 넣음에 따라 다르게 동작**하게 되는데,  이에 대해서는 예시를 통해 자세하게 알아보자.     

#### 🔑 (1) <u>인수 2개를 넣은 경우</u>

   ```go
var slice = make([]int, 3)
   ```
위 예제에서의 slice는 len이 3이고, cap이 3으로 총 길이가 3, 요소 개수도 3이다.     

#### 🔑 (2) <u>인수 3개를 넣은 경우</u>   

   ```go
var slice2 = make([]int, 3, 5)
   ```

이번 예제에서의 slice2는 len는 3, cap은 5인 슬라이스로 총 길이는 5, 요소의 개수는 3이다.     
말하자면 총 5개 중 3개만 사용하고 나머지 2개는 나중에 추가될 요소를 위해서 비워두었다고 보면 됨.           

### 📌 [2] <u>슬라이스와 배열의 동작 차이</u>

둘의 동작 차이는 예시를 들어 확인해보자.    

   ```go
package main

import "fmt"

func changeArray(array2 [5]int) {
	array2[2] = 200
}

func changeSlice(slice2 []int) {
	slice2[2] = 200
}

func main() {
	array := [5]int{ 1, 2, 3, 4, 5 }
	slice := []int{ 1, 2, 3, 4, 5 }
	
	changeArray(array)
	changeSlice(slice)
	
	fmt.Println("array:", array)
	fmt.Println("slice:", slice)
}
   ```

위 코드의 출력 결과는 다음과 같았다.    

   ```go
array: [1 2 3 4 5]
slice: [1 2 200 4 5]
   ```

### 📌 [3] <u>동작 차이의 원인</u>

위의 예시에서 slice의 3번째 값은 200으로 바뀌었는데 `changeArray()`의 인수로 사용한 `array` 배열의 3번째 값이 바뀌지 않음!  
왜 이런 일이 벌어진 걸까.     
바로 **배열과 슬라이스의 구조가 서로 다르기 때문**이다.     

**Go 언어에서는 모든 값의 대입은 복사로 일어난다**는 것을 염두에 두고 `changeArray()`함수가 호출될 때를 살펴보자.    
`chageArray()` 함수의 인수로 `array`를 입력해서 호출하면 `array`값이 `array2`로, 총 40(8 * 5 = 40)바이트가 복사되고, 이때, **`array`와 `array2`는 메모리 공간이 다른, 즉, 완전히 다른 배열**이기 때문에 `array2`의 세번째 값을 200으로 변경해도 `array`배열은 변경되지 않는다.      

이제 `changeSlice()`함수가 호출되는 경우를 살펴보자.   
`slice` 타입은 `[]int`로, 그 내부는 `포인터`, `len`, `cap` 세 개의 필드를 갖는 구조체이다. `slice` 값이 `slice2`로 복사되면 구조체의 각 필드값이 복사되기 때문에 `포인터`의 메모리 주솟값도 복사되고, `len`, `cap`값도 복사된다.     
즉, 똑값은 **메모리 주솟값**을 가지기 때문에 **`slice`와 `slice2` 모두 같은 배열 데이터를 가리키게 되고, slice2의 요솟값을 바꾸면 slice의 요솟값 또한 변경되는 것이다!**    

### 📌 [4] <u>append()를 사용할 때 주의해야 할 점</u>

`append()`함수가 호출되면 먼저 **슬라이스에 값을 추가할 수 있는 빈 공간이 있는지 확인**한다.          

**남은 빈 공간의 개수가 추가하는 값의 개수보다 크거나 같은 경우**, **배열의 뒷부분에 값을 추가한 뒤 `len`값을 증가**시킨다.       

만약 **빈 공간이 없을 경우**에는 **새로운 더 큰 배열을 마련 (일반적으로 기존 배열의 2배 크기로 마련한다) 후, 기존 배열의 요소를 모두 새로운 배열에 복사하고 맨 뒤에 새로운 값을 추가**한다. 이 때, **`cap`**은 **새로운 배열의 길이 값**이 되고, **`len`**은 **기존 길이에 추가한 개수만큼 더한 값**이 되며, **`포인터`**는 **새로운 배열을 가리키는 슬라이스 구조체**를 반환한다.
   

<div class="notice--primary" markdown="1">
🌟 <strong><u>여기서 핵심!</u></strong>      

<strong>슬라이스 내부에는 <u>배열을 가리키는 포인터</u></strong>가 있고 <strong></u><code>append()</code></u>는 <u>슬라이스가 가리키는 배열에 빈 공간이 충분하다면 추가</u>하고, <u>그렇지 않다면 더 큰 배열을 만들어서 추가</u></strong>한다.   
      
</div> 
 

## 3. 슬라이싱

**슬라이싱 <sup>slicing</sup>** 은 **배열의 일부를 집어내는 기능**으로, 그 결과 **슬라이스를 반환**하고, 인덱스를 두개만 사용하면 **저장공간을 나타내는 `cap`**은 **배열의 총 길이에서 시작 인덱스를 뺀 만큼**이라고 보면 된다.     

<div class="notice--primary" markdown="1">
🌝 <strong><u>여기서 잠깐!</u> : <u>인덱스를 2개 사용하지 않는 경우는?</u></strong>     

<strong>인덱스를 3개 사용할 시 <code>cap</code>을 조절</strong>할 수 있는데, 이 경우에는 <strong>마지막 인덱스를 최대 인덱스</strong>로 간주하여 <strong>슬라이스의 <code>cap</code>값은 <code>최대 인덱스 - 시작인덱스</code></strong> 가 된다.              

   ```go
slice[ 시작인덱스: 끝인덱스 : 최대 인덱스 ]
   ```

정리하면, 슬라이싱할 때 세번째 인덱스를 생략하면 배열의 전체 길이를 다 사용하게 되고, 세번째 인덱스를 적어주면 그 인덱스까지만 배열을 사용하게 된다.    
      
</div>
   

말하자면 슬라이싱은 동사이고, 슬라이스는 그 결과인 명사라고 보면 됨!   

정의와 사용 방법은 다른 언어에서의 슬라이싱과 동일하므로 생략하겠다.      

<div class="notice--primary" markdown="1">
🌝 <strong><u>여기서 잠깐!</u></strong>    

슬라이싱하면 그 결과로 배열 일부를 가리키는 슬라이스를 반환한다.   
즉, <strong>새로운 배열이 만들어지는 것이 아니라, <u>배열의 일부를 포인터로 가리키는 슬라이스를 만들어 내는 것</u></strong>이라는 소리!                
      
</div>


## 4. 유용한 슬라이싱 기능 활용

**슬라이싱**과 **`append()`** 기능을 활용하면 **슬라이스를 복제**하고 **요소를 추가**, **삭제**할 수 있다. 
### 📌 [1] <u>슬라이스 복제</u>

**복제하고 싶은 슬라이스와 똑같은 길이의 다른 슬라이스를 만든 후, 모든 요솟값을 하나씩 복사**한다.     
이 때, **순회를 사용해서 모든 요솟값을 하나씩 복사**할 수도 있지만, **`append()`함수로 한 번에 복사**하여 넣어줄 수도 있음!    

또한 **내장함수 `copy()`를 사용하는 방법**도 있는데, **`copy() `함수는 첫번째 인수로는 복사한 결과를 저장하는 슬라이스 변수를, 두번째 인수로는 복사 대상이 되는 슬라이스 변수를 받고, 실제로 복사된 요소의 개수를 반환**한다. 이 때, 실제 복사되는 요소의 개수는 목적지의 슬라이스 길이와 대상의 슬라이스 길이 중 **작은 개수**이다.   

### 📌 [2] <u>요소 삭제</u>

**슬라이스 중간 요소를 삭제하고, 중간 요소 이후의 값을 앞당겨서 삭제된 요소를 채운 후, 맨 마지막 값을 지워주면 된다.**   

이 역시 아래와 같이 **`append()` 함수**를 이용하면, 순회를 사용해서 값을 하나씩 앞당기는 부분의 코드를 줄여줄 수 있다.    

   ```go
slice = append(slice[:idx], slice[idx+1:])
   ```

### 📌 [2] <u>요소 추가</u>

**슬라이스 맨 뒤에 요소를 하나 추가해 준 후, 맨 뒤값부터 삽입하려는 위치까지 한 칸씩 뒤로 밀어준 후, 삽입하는 위치의 값만 바꿔주면** 끝!   

추가 과정에서도 동일하게 **`append()` 함수로 코드를 줄일 수 있다**.    

   ```go
slice = append(slice[:idx], append([]int{100}, slice[idx:]...)...)
   ```
또한, 위의 **`append()` 과정에서 사용되는 불필요한 메모리를 줄이기 위해 `copy()` 함수를 사용**할 수도 있다.    
`slice` 맨 뒤에 요소를 추가한 후, 내장 함수 `copy()`를 이용해서 한 칸씩 밀리도록 한 후, idx 위치에 값을 대입하면 됨.      

   ```go
slice = append(slice, 0)
slice = copy(slice[idx+1:], slice[idx:])
slice[idx] = 100
   ```

## 5. 슬라이스 정렬

### 📌 [1] <u>int 슬라이스 정렬</u>

정렬되지 않은 `int 슬라이스`는 **`sort 패키지`의 `Ints()` 함수**를 이용하면 간단하게 정렬할 수 있다.    
`sort` 패키지의 `Ints()` 함수 대신 **`Float64s()` 함수**를 이용하면 `float64 슬라이스`도 정렬할 수 있다!

### 📌 [2] <u>구조체 슬라이싱 정렬</u>

**구조체**에서는 **`Len()`, `Less()`, `Swap()`이라는 `sort.Interface 메서드`를 만들어 주어야 `Sort()`함수를 이용**할 수 있다.    

아래 예시를 보면 이해하기가 쉬울 것이다.

   ```go
package main

import (
	"fmt"
	"sort"
)

type Student struct {
	Name string
	Age int
}

type Students []student

func (s Students) Len() int { return len(s) }
func (s Students) Less(i, j int) bool { return s[i].Age < s[j].Age }
func (s Students) Swap(i, j int) { s[i], s[j] = s[j], s[i] }


func main() {
	s := Student{
		{"화랑", 31}, {"백두산", 52}, {"류", 42}, {"켄", 38}, {"송하나", 18} 
		}
		
	sort.Sort(Students(s))
	fmt.Println(s)
}
   ```
       
# 🌟 오늘의 핵심      

<div class="notice--primary" markdown="1">

1. 슬라이스는 Go 언어에서 제공하는 동적 배열 자료구조이다.          
  
2. append()를 이용해서 슬라이스에 값을 추가한다.           

3. 슬라이스가 같은 배열을 가리킬 경우 예기치 못한 문제가 발생할 수 있다.         

4. 슬라이싱은 배열 일부를 집어내는 기능으로, 그 결과 슬라이스가 반환된다.    

5. append()와 슬라이싱 기능을 이용해 다양한 활용이 가능하다.    

6. sort 패키지를 사용해서 슬라이스를 정렬할 수 있다.    

7. 슬라이스는 실제 배열 메모리를 가리키는 포인터를 가지고 있어서 배열에 비하여 메모리 사용량이나 속도에서 이점이 존재한다.    

</div>

_


# 👩🏻‍💻 관련 추가 과제

## 1번
Q) 다음 예제의 결과를 쓰세요.

   ```go
package main

import "fmt"

func main() {
	array := [5]int{1, 2, 3, 4, 5}
	slice := array[1:3]

	slice = append(slice, 100)
	fmt.Println(array)
}
   ```   
slice가 array 메모리를 포인터로 가지므로 array의 4번째 값 또한 변경된다.

A) 

   ```go
[1 2 3 100 5]
   ```

## 2번 

Q) 다음 슬라이스가 있을 때 처음부터 마지막 두 번째 전까지 잘라내는 구문을 쓰세요.            

   ```go
slice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
   ```
**마지막 "<u>두번째</u>" "<u>전</u>"까지**라는 말에 주목하면 됨!

A) 

   ```go
slice[:-2]
   ```

## 3번 

Q) 다음 예제의 결과를 쓰세요.            

   ```go
package main

import "fmt"

func main() {
	slice := []int{1, 2, 3, 4, 5, 6}
	t, slice := slice[len(slice)-1], slice[:len(slice)-1]

	fmt.Println(t, slice)
}
   ```
`t`는 슬라이스의 마지막 값을, `slice`는 슬라이싱 후 슬라이스의 값을 나타낸다.

A) 

   ```go
6 [1, 2, 3, 4, 5]
   ```

## 4번 

Q) 다음 선수 데이터를 표현하는 구조체를 만든 뒤 높은 득점부터 낮은 순으로 정렬하세요.            

<img width="810" alt="스크린샷 2021-08-24 오후 5 53 40" src="https://user-images.githubusercontent.com/63195670/130587775-aee1c82f-bd7a-4c3b-a0b1-f3b91cc5f9fb.png">

A) 

   ```go
package main

import (
	"fmt"
	"sort"
)

type Player struct {
	Name 			string
	Age 			int
	Score 			int
	PassSuccessRate float64
}

type Players []Player

func (p Players) Len() int { return len(p) }
func (p Players) Less(i, j int) bool { return p[i].Score < p[j].Score }
func (p Players) Swap(i, j int) { p[i], p[j] = p[j], p[i] }


func main() {
	p := Players{
		{"나통키", 13, 45, 78.4}, {"오맹태", 16, 24, 67.4}, {"오동도", 18, 54, 50.8}, {"황금산", 16, 36, 89.7} 
		}
		
	sort.Sort(sort.Reverse(Players(p)))
	fmt.Println(p)
}
   ```
