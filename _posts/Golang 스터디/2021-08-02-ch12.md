---
title: "[21.08.02] Golang_스터디 CH_12"
date: 2021-08-02 15:00:28 -0400
toc: true
toc_sticky: true
categories: Golang_Study
---


# 배열 

##  1. 배열

배열은 같은 타입의 데이터들로 이루어진 타입이다.     
배열을 이루는 각 값은 요소라고 하고, 요소를 가리키는 위치값을 인덱스라고 한다.    
배열은 같은 타입의 여러 데이터를 하나의 변수로 효과적으로 사용할 수 있도록 해줌.    
   

   ```go
var 변수명 [요소 개수] 타입 = [요소 개수] 타입{ 요소 값 }
   ```

배열의 인덱스는 `0`부터 시작하므로 `변수명[0]`이 첫 번째 값이다.    
그래서 배열의 마지막 요소 인덱스는 `배열 길이 - 1`이다.   

<div class="notice--primary" markdown="1">
⚠️ <strong><u>여기서 주의!</u></strong>      

배열의 인덱스 범위를 벗어나서 접근하면 에러가 발생한다.     
      
</div>  


##  2. 배열 사용법

### [1] 배열 변수 선언 및 초기화
 
각각의 예시를 통해 배열 변수 선언과 초기화 방법에 대해서 알아보자.    

  ```go
var nums [5]int
  ```

위 예시는 `int`형 타입 요소를 5개 갖는 배열 `nums`를 할당.     
별도로 **<u>초깃값을 지정하지 않아</u>** 각 요솟값은 `int` 타입의 **기본값**인 `0`으로 초기화된다.     

  ```go
days := [3]string{"monday", "tuesday", "wednesday"}
  ```
`string` 타입의 요소를 3개 갖는 배열 `days` 할당.      
각 요솟값을 "monday", "tuesday", "wednesday" 로 초기화했다.    


   ```go
var temps [5]float64 = [5]float64{24.3, 26.7}
   ```

`float64` 타입의 요소를 5개 갖는 배열 `temps` 할당.      
첫 번째 요솟값과 두 번째 요솟값은 각각 `24.3`과 `26.7`로 초기화 되는 반면, 나머지는 `float64` 타입의 **기본값**인 `0.0`으로 초기화 된다.    

   ```go
var s = [5]int{1:10, 3:30}
   ```

`int` 타입의 요소를 5개 갖는 배열 `s` 할당.      
**인덱스**가 `1`인 요솟값과 `3`인 요솟값은 각각 `10`과 `30`로 초기화 되는 반면, 나머지는 `int` 타입의 **기본값**인 `0`으로 초기화 된다.    

   ```go
x := [...]int{10, 20, 30}
   ```

`...`를 사용하여 배열 요소 개수를 생략할 수 있다.    
이때 배열 요소의 개수는 초기화되는 요소 개수와 같다.


<div class="notice--primary" markdown="1">
🌟 <strong><u>여기서 핵심!</u></strong>      

 - 별도로 초깃값이 지정되지 않은 요소가 존재할 경우, 타입의 기본값으로 초기화된다.    
 - <code>요솟값</code> 대신 <code>인덱스값 : 요솟값</code> 으로 중괄호 안에 넣어줄 경우, 해당 인덱스값을 요솟값으로 초기화할수 있다.     
 - <code>...</code>를 사용하여 배열 요소 개수를 생략할 수 있다.    
      
</div>    

### [2] 배열 선언 시 개수는 항상 상수

**<u>배열 선언 시 개수는 항상 상수</u>**로 써야 한다.     

예시를 통해 조금 더 살펴보자.     

#### 실행코드

   ```go
package main

const Y int = 3  // 상수로 설정    

func main() {
	x := 5  // 변수    
	a := [x]int{1, 2, 3, 4, 5}  // (3)
	
	b := [Y]int{1, 2, 3}    
	
	var c [10]int
}
   ```

#### 출력결과

   ```go
./ex12.2.go:11:8: non-constant array bound x
   ```
   
(3)에서 **변수**로 선언된 `x`는 배열 길이로 사용될 수 없기에 에러가 발생한다.     
하지만 `b`는 `Y`가 **상수**로 선언됐기 때문에 에러가 발생하지 않는다.   
`c` 역시 배열 길이를 지정하는데 **상수** `10`이 사용되었기 때문에 에러가 발생하지 않는다.

### [3] 배열 요소 읽고 쓰기

배열 요소에 접근하여 값을 읽고 쓰려면 **배열 변수에 대괄호 `[]`를 쓰고 그 사이에 접근하고자 하는 요소의 인덱스를 적으면 된다**.        

<div class="notice--primary" markdown="1">
🌝 <strong><u>여기서 잠깐!</u></strong>      

<code>len() 함수</code>로 <strong><u>배열의 길이</u></strong>를 알 수 있다.    
<code>len() 함수</code> 입력으로 <strong><u>배열 변수</u>를 넣으면 <u>배열 길이</u>를 반환</strong>한다.	
      
</div>     

### [4] range 순회

for 반복문에서 range 키워드를 이용하면 배열 요소를 순회할 수 있다.     
다음 예시를 보면 이해가 쉬울 것이다.      

#### 실행코드

   ```go
package main

import "fmt"   

func main() {
	var t [5]float64 = [5]float64{24.0, 25.9, 27.8, 26.9, 26.2}
	
	for i, v := range t{
		fmt.Println(i, v)
	}
}
   ```

#### 출력결과

   ```go
0 24
1 25.9
2 27.8
3 26.9
4 26.2

   ```
위 예시를 통해 for문 안에 range를 사용하여 모든 배열 요소를 순회하면서 인덱스와 요솟값 두 값을 반환할 수 있다는 걸 확인할 수 있을 것이다.        
선언 대입문을 사용하여 `i` 변수에는 **인덱스값을 대입**하고 `v` 변수에는 **요솟값을 대입**하였다.     

<div class="notice--primary" markdown="1">
🌝 <strong><u>여기서 잠깐!</u></strong>      

인덱스가 필요없고 요솟값만 필요하다면 밑줄<code>_</code>을 이용해서 인덱스를 무효화할 수 있다.      

   ```go
for _, v := range t {
	fmt.Println(v)
}
   ```
</div> 


<div class="notice--primary" markdown="1">
⚠️ <strong><u>여기서 주의!</u></strong>      

선언하고 사용하지 않는 변수가 있다면 컴파일 에러가 발생한다.    
따라서 <strong>range을 사용할 때 인덱스를 사용하지 않는다면 밑줄 <code>_</code>을 사용해서 첫 번째 값을 반드시 무효화</strong>하자.        
</div> 

range 순회는 배열뿐 아니라 문자열, 슬라이스, 맵, 채널 등에도 사용할 수 있다.

##  3. 배열은 연속된 메모리

배열을 선언하면 컴퓨터는 연속된 메모리 공간을 확보한다.    
예를 들어,

   ```go
var a [10]int32
   ```

위와 같이 선언하면, 컴퓨터는 `int32`값 10개를 저장할 수 있는 연속된 메모리 공간을 찾아 할당하고(`int32` 타입은 4바이트이므로 연속된 40바이트를 찾아 할당한다), 찾아갈 때는 **`배열의 시작 주소`에 '`인덱스 X 타입 크기`'를 더해서** 찾아간다.    

<div class="notice--primary" markdown="1">
🌟 <strong><u>여기서 핵심!</u></strong>      

 - 배열은 연속된 메모리이다.     
 - 컴퓨터는 인덱스와 타입 크기를 상요하여 메모리 주소를 찾는다.      
      
</div> 

##  4. 배열 복사

**대입 연산자**를 사용하면 **배열 대 배열 복사**를 할 수 있다.    

Go 언어에서 대입 연산자는 우변의 값을 좌변의 메모리 공간에 복사하는데, 이 때 복사되는 크기는 타입 크기와 같다.    
배열의 대입 역시 마찬가지임!     
	
   ```go
var a [5]int
var b [5]int

b = a
   ```
`a` 타입은 `[5]int` 타입으로 요소당 8바이트씩, 총 크기는 40바이트이다.    
`b` 타입도 `[5]int`로, `b = a`를 하면 a의 값을 b의 메모리 공간에 복사하는데, 이때 복사하는 크기는 타입 크기인 40바이트이다.     
이때 `a`의 값은 변수 `a`가 가리키는 메모리 공간의 값, 즉, **배열 전체**를 말하기에 **Go 언어에서 <u>배열 간 대입</u>은 <u>전체 배열의 복사</u>로 동작**한다.        

<div class="notice--primary" markdown="1">
⚠️ <strong><u>여기서 주의!</u></strong>      

Go 언어에서 모든 연산자의 각 항의 타입은 항상 같아야 한다.   
대입 연산자도 마찬가지이며, <code>b = a</code> 코드는 a와 b의 타입이 같지 않다면 에러가 발생한다.            
</div> 

##  5. 다중 배열

다중 배열은 **중첩 된 배열**로, 간단하게 말하자면 **배열을 요소로 가지는 배열**이라고 이해하면 쉽다.      

죽, 배열은 몇 개가 중첩됐든 **[개수] 타입** 형태!    

배열에 초깃값을 넣는데 { }를 사용했는데, 그렇다면 이중 배열에서는 어떻게 하면 될까?   
`변수명[0]`...`변수명[n]`을 **각각** `{ }`를 사용해 **초기화**하고, 그 둘을 다시 `{ }`로 **묶으면** 된다!

<div class="notice--primary" markdown="1">
⚠️ <strong><u>여기서 주의!</u></strong>      

초기화 시 <u>닫는 중괄호 `}`가 마지막 요소와 같은 줄에 있지 않은 경우 마지막 항목 뒤에 쉼표 `,`를 찍어줘야 한다.</u>           
</div> 

##  6. 배열 크기

**`배열 크기` `=` `타입 크기` `X` `항목 개수`**

<div class="notice--primary" markdown="1">
💡 <strong><u>추가 지식!</u></strong>      

배열을 이중, 삼중으로 선언하는 건 <u>데이터를 프로그래머가 다루기 편하기 위함</u>이지 <u>컴퓨터 입장에서는 메모리 크기만 중요하고 이중 배열이냐 삼중 배열이냐는 중요하지 않다.</u>      
그래서 컴퓨터 입장에서는 [3][2][5]int이나 [30]int이나 처리하는 방법은 같음!    
단지 배열 내 항목을 접근할 때 [0][1][3]과 같이 여러 차수로 접근할 수 있느냐 [8]과 같이 하나의 차수로 접근하냐가 다를 뿐이다.          
</div> 

# 관련 추가 과제

## 1. 다음 예제의 결과를 쓰세요.

   ```go
package main 

import "fmt"

func main(0 {
	a := [5]int{1, 2, 3, 4, 5}
	
	for i,v := range a {
		a[i] = v * 2
	}
	
	fmt.Println(a[2])
}
   ```

위 코드는 `a`배열을 순회하면서 각 요소값에 2를 곱한 값을 저장한다!

### A) 

   ```go
6
   ```

## 2. 다음 배열의 크기를 쓰세요.

   ```go
[3][2][5]float64
   ```


`float64` 크기의 요소가 `3 * 2 *5` 개 있다고 생각하면 된다.    
참고로 `float64` 크기는 8바이트임!    
### A) 240 바이트

`8 * 3 * 2 * 5` = 240 바이트


## 3. 다음 예제의 결과를 쓰세요.

   ```go
package main 

import "fmt"

func ChangeArray(arr [5]int) {
	arr[3] = 3000
}

func main() {
	a := [5]int{1, 2, 3, 4, 5}
	
	ChangeArray(a)
	
	fmt.Println(a[3])
}
   ```
`ChangeArray`는 `arr`를 파라미터로 받아서 `3`번째 index 요소값을 `3000`으로 바꾸어주는 함수이다.     
단, `ChangeArray()` 함수의 인수로 `a` 값이 **복사**되므로 **`arr`와 `a`는 서로 다른 배열**임!    
즉, **`arr[3]` 값을 바꾸어도 `a[3]`은 바뀌지 않는다는 뜻**!

### A)

   ```go
4
   ```
