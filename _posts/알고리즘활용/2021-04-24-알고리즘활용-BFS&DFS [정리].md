---
title: "[21.04.24] 알고리즘활용스터디 - BFS & DFS[정리]"
date: 2021-04-24 10:30:28 -0400
toc: true
toc_sticky: true
categories: Algorithm_Study
---

# [BFS와 DFS]

우선, BFS와 DFS를 살펴보기 전, 그래프 구현 방법에 대한 지식이 필요한 것 같아 먼저 공부해 봤다.    

그래프를 구현하는 방법으로는 **인접 행렬(Adjancency Matrix)**을 사용하는 방법과 **인접 리스트(Adjacency List)**를 사용하는 방법이 있는데, 두 가지 방법 모두 그래프의 **각 노드별로 "인접"하는 노드의 정보를 저장**한다는 공통점을 가진다. 

차이는 **인접 행렬**은 **2차원 배열의 형태로 정보를 저장**하고 **인접 리스트**는 **linked list의 형태로 정보를 저장**한다는 것! (이로 인해 메모리 사용량, 처리 속도, 구현의 복잡성 등에서 차이가 발생한다.)

## 1. 인접 행렬 

그래프의 연결 관계를 이차원 배열로 나타내는 방식이다.     
인접 행렬을 adj[][]라고 한다면 adj[i][j]에 대해서 다음과 같이 정의할 수 있다.
	
		adj[i][j] : 노드 i에서 노드 j로 가는 간선이 있으면 1, 아니면 0
		
		* 만약 간선에 가중치가 있는 그래프라면 1 대신에 가중치의 값을 직접 넣어주는 방식으로 구현할 수 있다.

<img width="749" alt="스크린샷 2021-04-23 오후 5 00 35" src="https://user-images.githubusercontent.com/63195670/115942284-6a6d9f80-a4e4-11eb-95e8-641c7c8decdd.png">  
    
예를 들어 다음과 같은 그래프가 있을 때, 이 그래프의 연결 관계를 인접 행렬로 나타낸다면 다음과 같다.

그렇다면 위의 그래프와 같이 간선에 방향이 있는 유향 그래프가 아닌, 간선에 방향이 없는 무향 그래프의 경우에는 어떻게 될까. 

<img width="749" alt="스크린샷 2021-04-23 오후 5 03 45" src="https://user-images.githubusercontent.com/63195670/115942277-66418200-a4e4-11eb-96ea-caaf7044015f.png">
    
노드 i에서 노드 j로 가는 간선이 있다는 말은 노드 j에서 노드 i로 가는 간선도 존재한다는 의미이다.       
따라서, 인접 행렬이 대각 성분(adj[i][j]에서 i와 j가 같은 원소들)을 기준으로 **대칭인 성질**을 갖게 된다.      
위의 그래프의 간선들을 방향이 없는 간선으로 바꿔주면 아래와 같은 인접행렬을 갖게 된다.


인접 행렬의 장점은 구현이 쉽다는 점이다.

그리고, 노드 i와 노드 j가 연결되어 있는지 확인하고 싶을 때, adj[i][j]가 1인지 0인지만 확인하면 되기 때문에 O(1)이라는 시간 복잡도에 확인할 수 있다. 

하지만, 치명적인 단점 또한 존재한다. 

전체 노드의 개수를 V개, 간선의 개수를 E개라고 한다면, 노드 i에 연결된 모든 노드들에 방문해보고 싶은 경우 adj[i][1]부터 adj[i][V]를 모두 확인해보아야 하기 때문에 총 O(V)의 시간이 걸리게 된다. 

위의 그래프와 같은 경우 큰 차이가 느껴지지 않을 수도 있지만, 노드의 개수에 비해 간선의 개수가 훨씬 적은 그래프라면 이야기가 달라질 것이다. 

만약, 노드의 개수는 총 1억개인데 각 노드마다 연결된 간선이 많아봤자 2개인 그래프가 있다고 가정해보자. 그렇다면, 특정 노드와 연결된 노드들이 몇 번 노드인지 확인하기 위해 총 1억 개의 노드들을 모두 확인해봐야 하는 치명적인 문제가 발생하게 된다. 정작 연결된 노드는 많아봤자 2개 뿐일텐데 말이다. (이러한 단점을 보완할 수 있는 연결 관계 표현 방식이 바로 인접 리스트!)

## 2. 인접 리스트

그래프의 연결 관계를 vector의 배열(vector<int> adj[])로 나타내는 방식이다. 이 때, vector<int>에는 노드의 번호가 직접 저장된다. 인접 리스트는 adj[i](vector의 배열이기 때문에, adj[i]는 vector가 되겠다.)를 다음과 같이 정의할 수 있다. 

	adj[i] : 노드 i에 연결된 노드들을 원소로 갖는 vector
	
	* 만약 간선에 가중치가 있다면, pair<int, int> adj[]를 통해 구현할 수 있다. 
	  pair<int, int>의 first에는 노드의 번호, second에는 간선의 가중치를 저장하는 방식으로 저장해 주면 된다.

이번에도 간단한 예시를 통해 이해해 보자. 

<img width="896" alt="스크린샷 2021-04-24 오전 10 11 55" src="https://user-images.githubusercontent.com/63195670/115942506-99384580-a4e5-11eb-86ec-eb098c956681.png">

위의 그림에서 편의상, 벡터를 linked list와 같은 형태로 나타내었고 (vector는 push_back을 통해 뒤에 원소를 계속 붙일 수 있기 때문에 linked list의  형태와 비슷하다고 생각하면 편하기 때문 -> c언어는 linked list로 구현하면 될 듯하다.) , 보기 좋도록 adj[]를 세워서 나타냈다.     
왼쪽의 그래프를 보면, 노드 1과 연결된 노드는 노드 2, 3, 4. 총 세 개가 있다. 따라서, adj[1]의 vector는 총 세 개의 성분을 갖게 된다. 각각의 성분에 접근하기 위해선 이차원 배열과 같은 방식을 이용하면 되는 것. (adj[1][0] = 2, adj[1][1] = 3, adj[1][2] = 4, adj[2][0] = 3) 


* 오른쪽의 인접 리스트에서, **adj[1]에 있는 세 노드의 순서는 의미가 없다**. 2,3,4 순이 아닌 3,2,4 순이 되어도 무관하지만, 보기 좋도록 하기 위해 오름차순으로 저장해 놓은 것일 뿐이다.     
  따라서, adj[1]의 노드 2와 노드 3사이에 화살표가 있는 것을 **노드 2와 노드 3사이에 간선이 있다는 의미가 아니라 단순히, vector에 노드 3이 노드 2보다 나중에 push_back 되었기 때문이라고 이해**하면 된다.



그렇다면, 간선에 방향이 없는 무향 그래프의 경우 인접 리스트가 어떻게 될까?

그림으로 간단하게 이해하고 넘어가도록 하자.

<img width="749" alt="스크린샷 2021-04-23 오후 5 19 25" src="https://user-images.githubusercontent.com/63195670/115942281-693c7280-a4e4-11eb-8806-7e2acf7b9fd3.png">

그렇다면, 인접 리스트로 그래프의 연결 관계를 저장할 때의 장점은 무엇일까. 

인접 리스트는 인접 행렬과 달리, 실제로 연결된 노드들에 대한 정보만 저장하기 때문에, 모든 벡터들의 원소의 개수의 합이 간선의 개수와 같다는 점이 있다. 즉, 간선의 개수에 비례하는 메모리만 차지한다고 할 수 있는 것! 위의 그림만 봐도 이러한 점을 확인할 수 있다. 그래프에 5개의 간선이 존재하고, 따라서 인접 리스트 상에 저장된 원소도 5개인 것을 확인할 수 있다.

만약, 노드 2와 연결된 모든 노드들을 방문해보고 싶다면, 인접 행렬의 경우 adj[2][1], adj[2][2], adj[2][3], adj[2][4]. 총 4번을 확인해보아야 하지만, 인접 리스트의 경우 실제 연결된 노드들만 확인해 볼 수 있기 때문에 adj[2][0] 부터 adj[2][adj[2].size()-1] 까지 총 1번만 확인해보면 된다. 

이를 전체 노드에 대한 탐색을 수행하는 상황으로 확장해서 생각해보도록 하자. 노드가 V개, 간선이 E개라고 가정해 보면, 인접 행렬의 경우,  각 노드에 연결된 노드를 방문해보기 위해서 모든 노드에 대해 확인해보아야 하기 때문에 총 O(V*V)의 시간이 걸릴 것이다. 하지만, 인접 리스트의 경우에는 각 노드마다 연결된 노드만 확인하는 것이 가능하기 때문에, 전체 간선의 개수만큼만 확인해 볼 수가 있다. 따라서, O(E)의 시간복잡도를 가진다고 할 수 있는 것이다. 이렇게 각 노드에 연결된 모든 노드들을 방문해 보아야 하는 경우, 인접 리스트로 연결 관계를 저장하는 것이 시간상 큰 이점을 가진다고 할 수 있다. 

하지만, 인접 리스트에도 치명적인 단점이 존재한다.

 노드 i와 노드 j가 연결되어 있는지 알고 싶다면 어떻게 해야 할까. adj[i]의 벡터 전체를 돌며, j를 성분으로 갖는지 확인해보아야 할 것이다. 따라서, 위에서 언급했듯이, 인접 행렬의 경우 adj[i][j]가 1인지 0인지만 확인하면 되기 때문에 O(1)의 시간 복잡도를 갖는 데 반해 인접 리스트의 시간 복잡도는 O(V)가 된다.      
 
 이러한 단점이 있기 때문에, **문제의 상황에 따라 적절한 표현 방식을 이용해서 연결 관계를 저장하는 것이 중요하다**고 할 수 있다.


-


자, 이제 그래프에서의 탐색 방법에 대해 알아보도록 하자.


그래프의 정점을 모두 한 번씩 방문하는 알고리즘을 **순회 알고리즘(Traversal Algorithm)**이라고 한다.

크게 두 가지 종류가 있는데, 하나는 **깊이 우선 탐색(DFS, Depth First Algorithm)**이고, 하나는 **너비 우선 탐색(BFS, Breadth First Algorithm)**이다.

**DFS(깊이 우선 탐색)**와 **BFS(너비 우선 탐색)**는 **탐색**을 할 때 사용한다.

++ 백준 알고리즘 1260번!

## 1. 깊이 우선 탐색 (DFS)

DFS는 다음과 같은 간단한 알고리즘에 따라서 작동한다.

	1. 스택의 최상단 노드를 확인한다.
	2. 최상단 노드에게 방문하지 않은 인접 노드가 있다면 그 노드를 스택에 넣고 방문처리한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 뺀다.

위 알고리즘을 계속해서 반복 수행하면 끝!

인접한 정점이 존재한다면 계속 한 우물만 깊게 파고드는 타입.     
만약 인접한 정점이 존재하지 않는 정점(이른바 막다른 길)을 발견한다면, 이 전에 있었던 정점으로 돌아가서 또 새롭게 팔 우물이 있는지 살펴본다.     
일단 "길이 있으면 가고 본다!!" 라는 막무가내 타입이기 때문에,   
  
1. 인접해있고      
2. 한번도 방문한 적이 없다면,      
바로 해당 정점으로 탐색

하러 가는 편.

* 위 과정을 대부분의 프로그래밍에서는 **재귀함수**를 이용해서 구현하는 경우가 많다.

* 준비물 : 정점의 방문 여부를 체크해줄 배열, 인접 여부를 체크해줄 행렬(혹은 리스트), 재귀함수에 대한 개념)

C++ 로 코드 구현하면 다음과 같다.

	#include <iostream> 
	#include <vector> 
	
	using namespace std; 
	
	int number = 9; 
	int visit[9]; 
	vector<int> a[10]; 
	void dfs(int start){ 
	   if(visit[start]){ 
	         // 방문한경우 바로 빠져나옴.
	         return;
	         } 
	         
	         visit[start] = true; // 방문 
	         printf("%d ", start); 
	         
	         
	         for(int i=0; i< a[start].size(); i++){ 
	                // 인접한 노드를 방문
                        int x = a[start][i]; 
                        dfs(x); 
                        } 
           } 
           
           int main(void){ 
                  // 1과 2를 연결
                  a[1].push_back(2); 
                  a[2].push_back(1); 
                  
                  // 1과 3을 연결 
                  a[1].push_back(3); 
                  a[3].push_back(1); 
                  
                  // 2과 3을 연결 
                  a[2].push_back(3); 
                  a[3].push_back(2); 
                  
                  // 2와 4를 연결 
                  a[2].push_back(4); 
                  a[4].push_back(2); 
                  
                  // 2와 5를 연결 
                  a[2].push_back(5); 
                  a[5].push_back(2); 
                  
                  // 4와 8을 연결 
                  a[4].push_back(8); 
                  a[8].push_back(4); 
                  
                  // 5와 9를 연결 
                  a[5].push_back(9); 
                  a[9].push_back(5); 
                  
                  // 3과 6을 연결 
                  a[3].push_back(6); 
                  a[6].push_back(3); 
                  
                  // 3과 7을 연결 
                  a[3].push_back(7); 
                  a[7].push_back(3); 
                  
                  // 1번 노드부터 bfs 탐색 실행 
                  dfs(1); 
                  
                  return 0; 
          }​
          
##    2.  너비 우선 탐색 (BFS)

깊이 우선 탐색이 날카롭고 "깊게" 파고드는 탐색 알고리즘이었다면 너비 우선 탐색은 "넓게 넓게" 파고드는 탐색 알고리즘이라고 보면 된다.   

DFS에서 하나의 노드를 기준으로 더 이상 방문할 노드가 없을 때까지 점점 더 깊이 파고들며 탐색했다면 BFS에서는 하나의 노드를 기준으로 더 이상 방문할 노드가 없을 때까지 해당 노드에 연결되어 있는 모든 노드들을 방문하는 것.
 
일단 인접한 정점을 발견하면 거길 탐색하고 다시 캠프로 돌아와서 다음 인접 정점을 탐색하는 식이다.    
 
이런 식으로 하다보니 자연스럽게 **레벨 별로 탐색**이 이루어진다.       
(레벨 0인 정점) (레벨 1의 정점들) (레벨 2의 정점들)....(레벨 n의 정점들)     
바로 이렇게!

DFS와 마찬가지로 방문여부를 알려주는 배열, 인접 여부를 알려주는 행렬(혹은 리스트)가 있으면 되는데, 추가로 **"큐(queue)"**가 필요하다.      
일단 인접한 정점을 발견하면 큐에 넣어두고, 큐가 다 비어버릴 때까지 Pop시키면서 해당 Pop 정점에 대해 또 인접한 정점을 찾아보고, 찾으면 또 큐에 넣고, 주변을 다 살폈으면 다시 큐에서 Pop시켜서 또 인접한 정점을 찾아보는 과정의 반복이다.


	
	
###  # 출처	
* [그래프 구현 참고 사이트](https://sarah950716.tistory.com/12)     
* [BFS & DFS 참고 사이트](https://m.blog.naver.com/PostView.nhn?blogId=printfbns&logNo=221580482330&proxyReferer=https:%2F%2Fwww.google.com%2F)
