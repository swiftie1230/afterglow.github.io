---
title: "[21.04.01] 백준문제풀이-기본수학1(1)"
date: 2021-04-01 12:02:28 -0400
categories: jekyll update
---

[1712번] 손익분기점

​

문제)

월드전자는 노트북을 제조하고 판매하는 회사이다. 노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용이 들며, 한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.

예를 들어 A=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.

노트북 가격이 C만원으로 책정되었다고 한다. 일반적으로 생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다. 최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점(BREAK-EVEN POINT)이라고 한다.

A, B, C가 주어졌을 때, 손익분기점을 구하는 프로그램을 작성하시오.

​

입력)

첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 21억 이하의 자연수이다.

​

출력)

첫 번째 줄에 손익분기점 즉 최초로 이익이 발생하는 판매량을 출력한다. 손익분기점이 존재하지 않으면 -1을 출력한다.

​

#include<stdio.h>

​

int main()

{

int A,B,C;

int num = 0;

scanf("%d %d %d", &A, &B, &C);

​

if(B<C)

{

num = A/(C-B)+1;

printf("%d", num);

}

else if(B>=C)

printf("%d", -1);

}

​

사실 먼저 무한 반복문을 사용하여 최초로 이익이 발생하는 판매량을 구하려 했지만, 시간초과가 떴다.

그래서 A, B, C를 이용하여 손익분기점 변수인 num을 구하였다.

만약 C가 B보다 크면 수입이 비용을 넘어설 수 있다. 

노트북의 생산개수에 영향을 받지 않는 고정비용을 제외하고 가변비용만 놓고 본다면 노트북 한대마다 C-B 만큼의 이익이 남게 된다. 

매번 발생하는 C-B의 합이 고정비용 A를 넘게 되는 지점이 손익분기점이라고 할 수 있으므로 num = A/(C-B)+1이다.

만약 C가 B보다 작으면 수입이 비용을 절대 넘어설 수 없으므로, 문제에서 제시한 대로 -1을 출력한다.

​

[2292번] 벌집

​

문제)

![image](https://user-images.githubusercontent.com/63195670/113237168-579aed00-92e1-11eb-8ee5-94dbe4088b5f.png)

위의 그림과 같이 육각형으로 이루어진 벌집이 있다. 그림에서 보는 바와 같이 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 주소로 매길 수 있다. 숫자 N이 주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지(시작과 끝을 포함하여)를 계산하는 프로그램을 작성하시오. 예를 들면, 13까지는 3개, 58까지는 5개를 지난다.

​

입력)

첫째 줄에 N(1 ≤ N ≤ 1,000,000,000)이 주어진다.

​

출력)

입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.

​

#include<stdio.h>

​

int main()

{

int N=0;

int i=1;

scanf("%d", &N);

N--;

while(N>0)

{

N=N-6*i;

i++;

}

printf("%d",i);

}

​

2-7 : second layer, 8-19 : third layer, 20-37 : fourth layer

일단 1에서 시작하므로 second layer부터 1씩 세야 하기에 N--;을 한후, N이 0이 될때까지 6i로 나눈다.(while문 사용)

다음 layer로 갈수록 방수가 6씩 증가하므로 i는 1씩 증가시킨다.  그런 후, 마지막은 i를 출력하면 끝!

​

[1193번] 분수찾기

​

문제)

무한히 큰 배열에 다음과 같이 분수들이 적혀있다.

<img width="570" alt="스크린샷 2021-04-01 오전 11 59 09" src="https://user-images.githubusercontent.com/63195670/113237376-aba5d180-92e1-11eb-9f17-ccf775e9102f.png">

이와 같이 나열된 분수들을 1/1 -> 1/2 -> 2/1 -> 3/1 -> 2/2 -> … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자.

X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오.

​

입력)

첫째 줄에 X(1 ≤ X ≤ 10,000,000)가 주어진다.

​

출력)

첫째 줄에 분수를 출력한다.

​

#include <stdio.h>

int main()

{

int n,c=1;

scanf("%d", &n);

if(n==1)

{

printf("1/1");

return 0;

}

while(n-c>0) 

{

n-=c;

c++;

}

​

c++;

​

if((c-1)%2) 

printf("%d/%d",c-n,n);

else 

printf("%d/%d",n,c-n);

}

​

1/1 -> 1/2 -> 2/1 -> 3/1 -> 2/2 -> 1/3 -> 1/4 ... 이런 순서가 주어질 때, X를 입력받아 X번째 분수를 출력한다.

처음에는 대충 배열, 그리고 for문과 while문을 이용하여 때려맞출 생각을 하였지만, 시간제한이 0.5초였다.

그래서 조금 생각을 하고 문제를 다시보니, 분자는 1 1 2 3 2 1 1 2 3 4 5 4 3 2 1 ... 그리고 분모는 증감이 반대다.

<img width="484" alt="스크린샷 2021-04-01 오전 11 59 48" src="https://user-images.githubusercontent.com/63195670/113237431-c415ec00-92e1-11eb-9ae5-3861d0008c7e.png">

1이면 1/1을 출력하게 하고, 나머지 증감의 순서가 바뀌는 구간을 나누니 구간마다 분수의 수가 1 2 3 4 5 6 7 8 9 ... 로 일정하게 증가한다.

그래서 입력받은 수에서 1 2 3 4 5 6 ... 차례대로 뺀값이 0보다 클때까지 반복하였다.(while문을 사용해서)

구간의 처음 (1/1이 있는 구간) 부터 시작해서 구간의 개수를 셌을 때, 그 구간에서 분모와 분자의 합은 1 크므로 c를 1 증가시킨다.

그리고 마지막으로 c에서 입력받은 수를 뺀 수와 입력받은 수를 각각 분모이거나 분자인 것으로 풀었다.

​

[2869번] 달팽이는 올라가고 싶다.

​

문제)

땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.

달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.

달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.

​

입력)

첫째 줄에 세 정수 A, B, V가 공백으로 구분되어서 주어진다. (1 ≤ B < A ≤ V ≤ 1,000,000,000)

​

출력)

첫째 줄에 달팽이가 나무 막대를 모두 올라가는데 며칠이 걸리는지 출력한다.

​

#include <stdio.h>

int main()

{

int A,B,C;

int day, almost, days, answer;

​

scanf("%d %d %d", &A, &B, &C);

​

if(A == C)

{

printf("%d", 1);

return 0;

}

​

day = A - B;

almost = C - A;

​

if(almost % day)

{

days = (almost / day) + 1;

}

else

{

days = almost/day;

}

​

answer = days + 1;

​

printf("%d\n", answer);

​

return 0;

}

​

이 문제는 섣불리 어렵지 않네! 반복문으로 풀 수 있겠어. 라는 생각으로

while(1){ day++; V -= A;

if(V <= 0){ printf("%d",day); return 0; } V += B; }

하면 틀린다.

문제를 자세히 보면 입력값 A,B,V의 범위는 1 <= B < A <= V <= 1,000,000,000 이고 시간 제한은 0.15초이다. 만약 입력값이 무지막지하게 크게 들어온다면 과연 프로그램은 0.15초만에 연산을 끝낼수 있을까? 절대 아닐 것이다. 그러므로 이 문제를 풀기 위해서는 수식을 구하고 예외상황만 처리해야 한다.

​

달팽이가 정상에 도달하지 못한다면 낮과 밤동안 갈 수 있는 거리는 (A - B)이다. 정상에 도착하면 밤에는 미끄러지지 않으므로 (V - A)까지 온다면 다음날 무조건 정상에 도착한다. 따라서 (V-A)를 (A-B)로 나누면 V - A 까지 도달하는데 걸리는 시간을 구할 수 있다. 

이걸 코드로 짜보면 day = A - B; // 달팽이가 낮과 밤동안 갈 수 있는 거리 

almost = V - A; //이 거리까지 오면 달팽이는 무조건 다음날 도착한다.

howmany = almost / day; // almost 까지 가는데 걸리는 날짜 

answer = howmany + 1; //정상에 도달하려면 하루가 더 걸린다. 

​

이제 예외상황을 처리해줘야 한다. 먼저 입력값을 보면 달팽이가 낮에 갈 수 있는 거리인 A는 정상까지의 높이 V보다 작거나 같다. 즉 같은 값이 입력 될 수 있다는 것인데 그렇다면 달팽이는 하루만에 정상에 도달 할 수 있다.

if (A == V) { // 만약 올라가야되는 거리가 낮에 달팽이 갈 수 있는 거리와 같다면 

printf("%d", 1); // 하루만에 갈 수 있다.

return 0; } 

​

두번째로 다음날 무조건 도착하는 높이인 almost까지 도달하는데 걸리는 시간을 구할 때 almost를 day로 나눠주는데 이때 정수값이 나오지 않는다면, 그러니까 달팽이가 (almost/day)일 동안 열심히 가도 almost 까지 도달을 못한다면 하루를 추가해 줘야 된다.

if (almost % day) // almost 거리까지 가는데 걸리는 시간을 구할때 나머지값이 있다면 하루 더 추가 

howmany = (almost / day ) + 1; 

else howmany = almost / day; 

이렇게 예외상황들을 처리해준다면 완성된 코드는 다음과 같다.

<img width="428" alt="스크린샷 2021-04-01 오후 12 00 21" src="https://user-images.githubusercontent.com/63195670/113237469-d728bc00-92e1-11eb-8b2b-bbf1afedb5d6.png">

​

[10250번] ACM호텔

​

문제)

ACM 호텔 매니저 지우는 손님이 도착하는 대로 빈 방을 배정하고 있다. 고객 설문조사에 따르면 손님들은 호텔 정문으로부터 걸어서 가장 짧은 거리에 있는 방을 선호한다고 한다. 여러분은 지우를 도와 줄 프로그램을 작성하고자 한다. 즉 설문조사 결과 대로 호텔 정문으로부터 걷는 거리가 가장 짧도록 방을 배정하는 프로그램을 작성하고자 한다.

문제를 단순화하기 위해서 호텔은 직사각형 모양이라고 가정하자. 각 층에 W 개의 방이 있는 H 층 건물이라고 가정하자 (1 ≤ H, W ≤ 99). 그리고 엘리베이터는 가장 왼쪽에 있다고 가정하자(그림 1 참고). 이런 형태의 호텔을 H × W 형태 호텔이라고 부른다. 호텔 정문은 일층 엘리베이터 바로 앞에 있는데, 정문에서 엘리베이터까지의 거리는 무시한다. 또 모든 인접한 두 방 사이의 거리는 같은 거리(거리 1)라고 가정하고 호텔의 정면 쪽에만 방이 있다고 가정한다.

<img width="529" alt="스크린샷 2021-04-01 오후 12 00 54" src="https://user-images.githubusercontent.com/63195670/113237511-eb6cb900-92e1-11eb-9e88-e7e42974cb48.png">

그림 1. H = 6 이고 W = 12 인 H × W 호텔을 간략하게 나타낸 그림

방 번호는 YXX 나 YYXX 형태인데 여기서 Y 나 YY 는 층 수를 나타내고 XX 는 엘리베이터에서부터 세었을 때의 번호를 나타낸다. 즉, 그림 1 에서 빗금으로 표시한 방은 305 호가 된다.

손님은 엘리베이터를 타고 이동하는 거리는 신경 쓰지 않는다. 다만 걷는 거리가 같을 때에는 아래층의 방을 더 선호한다. 예를 들면 102 호 방보다는 301 호 방을 더 선호하는데, 102 호는 거리 2 만큼 걸어야 하지만 301 호는 거리 1 만큼만 걸으면 되기 때문이다. 같은 이유로 102 호보다 2101 호를 더 선호한다.

여러분이 작성할 프로그램은 초기에 모든 방이 비어있다고 가정하에 이 정책에 따라 N 번째로 도착한 손님에게 배정될 방 번호를 계산하는 프로그램이다. 첫 번째 손님은 101 호, 두 번째 손님은 201 호 등과 같이 배정한다. 그림 1 의 경우를 예로 들면, H = 6이므로 10 번째 손님은 402 호에 배정해야 한다.

​

입력)

프로그램은 표준 입력에서 입력 데이터를 받는다. 프로그램의 입력은 T 개의 테스트 데이터로 이루어져 있는데 T 는 입력의 맨 첫 줄에 주어진다. 각 테스트 데이터는 한 행으로서 H, W, N, 세 정수를 포함하고 있으며 각각 호텔의 층 수, 각 층의 방 수, 몇 번째 손님인지를 나타낸다(1 ≤ H, W ≤ 99, 1 ≤ N ≤ H × W). 

​

출력)

프로그램은 표준 출력에 출력한다. 각 테스트 데이터마다 정확히 한 행을 출력하는데, 내용은 N 번째 손님에게 배정되어야 하는 방 번호를 출력한다.

​

#include<stdio.h>

​

int main(void)

{

int T,H,W,N;

scanf("%d",&T);

for(int i=0;i<T;i++)

{

scanf("%d %d %d", &H, &W, &N);

int A1, A2 = 0;

if(N%H == 0)

{

A1 = H;

A2 = N/H;

}

else if(N%H!=0){

A1 = N%H;

A2 = N/H+1;

}

if(A2 < 10)

printf("%d%02d\n", A1, A2);

if(A2 >= 10)

printf("%d%02d\n", A1, A2);

}

return 0;

}

​

이 문제는 조금만 생각하면 일반 수식을 구할 수 있다.

다만 예외 상황이 방금 위에서 풀었던 문제와 동일하게 존재한다는 것!

그 예외상황만 제대로 캐치하고 코드를 적어준다면 어렵지 않다.

​

마지막에 %02d는 %d0%d로 출력하면 틀린다고 나온다. 이건 거기서 인식할 때 이것만 맞게 한것 같음..

%2d에 있는 2의 의미는 빈칸 2개를 의미!

%02d에 있는 02는, %2d에서 앞에 0이 추가된 것으로 빈칸을 2개로 하되, 그 빈칸에는 0을 넣겠다는 의미이다.
